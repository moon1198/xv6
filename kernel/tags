!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/root/xv6-labs-2023/kernel/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
.bss	kernel.ld	/^  .bss : {$/;"	S
.data	kernel.ld	/^  .data : {$/;"	S
.rodata	kernel.ld	/^  .rodata : {$/;"	S
.text	kernel.ld	/^  .text : {$/;"	S
BACKSPACE	console.c	/^#define BACKSPACE /;"	d	file:
BBLOCK	fs.h	/^#define BBLOCK(/;"	d
BPB	fs.h	/^#define BPB /;"	d
BSIZE	fs.h	/^#define BSIZE /;"	d
C	console.c	/^#define C(/;"	d	file:
CLINT	memlayout.h	/^#define CLINT /;"	d
CLINT_MTIME	memlayout.h	/^#define CLINT_MTIME /;"	d
CLINT_MTIMECMP	memlayout.h	/^#define CLINT_MTIMECMP(/;"	d
CONSOLE	file.h	/^#define CONSOLE /;"	d
DIRSIZ	fs.h	/^#define DIRSIZ /;"	d
Disassembly	kernel.asm	/^Disassembly of section .text:$/;"	l
ELF_MAGIC	elf.h	/^#define ELF_MAGIC /;"	d
ELF_PROG_FLAG_EXEC	elf.h	/^#define ELF_PROG_FLAG_EXEC /;"	d
ELF_PROG_FLAG_READ	elf.h	/^#define ELF_PROG_FLAG_READ /;"	d
ELF_PROG_FLAG_WRITE	elf.h	/^#define ELF_PROG_FLAG_WRITE /;"	d
ELF_PROG_LOAD	elf.h	/^#define ELF_PROG_LOAD /;"	d
FCR	uart.c	/^#define FCR /;"	d	file:
FCR_FIFO_CLEAR	uart.c	/^#define FCR_FIFO_CLEAR /;"	d	file:
FCR_FIFO_ENABLE	uart.c	/^#define FCR_FIFO_ENABLE /;"	d	file:
FD_DEVICE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	e	enum:file::__anonfd762ebb0103
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	e	enum:file::__anonfd762ebb0103
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	e	enum:file::__anonfd762ebb0103
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	e	enum:file::__anonfd762ebb0103
FSMAGIC	fs.h	/^#define FSMAGIC /;"	d
FSSIZE	param.h	/^#define FSSIZE /;"	d
IBLOCK	fs.h	/^#define IBLOCK(/;"	d
IER	uart.c	/^#define IER /;"	d	file:
IER_RX_ENABLE	uart.c	/^#define IER_RX_ENABLE /;"	d	file:
IER_TX_ENABLE	uart.c	/^#define IER_TX_ENABLE /;"	d	file:
INPUT_BUF_SIZE	console.c	/^#define INPUT_BUF_SIZE /;"	d	file:
IPB	fs.h	/^#define IPB /;"	d
ISR	uart.c	/^#define ISR /;"	d	file:
KERNBASE	memlayout.h	/^#define KERNBASE /;"	d
KSTACK	memlayout.h	/^#define KSTACK(/;"	d
LCR	uart.c	/^#define LCR /;"	d	file:
LCR_BAUD_LATCH	uart.c	/^#define LCR_BAUD_LATCH /;"	d	file:
LCR_EIGHT_BITS	uart.c	/^#define LCR_EIGHT_BITS /;"	d	file:
LOGSIZE	param.h	/^#define LOGSIZE /;"	d
LSR	uart.c	/^#define LSR /;"	d	file:
LSR_RX_READY	uart.c	/^#define LSR_RX_READY /;"	d	file:
LSR_TX_IDLE	uart.c	/^#define LSR_TX_IDLE /;"	d	file:
MAKE_SATP	riscv.h	/^#define MAKE_SATP(/;"	d
MAXARG	param.h	/^#define MAXARG /;"	d
MAXFILE	fs.h	/^#define MAXFILE /;"	d
MAXOPBLOCKS	param.h	/^#define MAXOPBLOCKS /;"	d
MAXPATH	param.h	/^#define MAXPATH /;"	d
MAXVA	riscv.h	/^#define MAXVA /;"	d
MIE_MEIE	riscv.h	/^#define MIE_MEIE /;"	d
MIE_MSIE	riscv.h	/^#define MIE_MSIE /;"	d
MIE_MTIE	riscv.h	/^#define MIE_MTIE /;"	d
MSTATUS_MIE	riscv.h	/^#define MSTATUS_MIE /;"	d
MSTATUS_MPP_M	riscv.h	/^#define MSTATUS_MPP_M /;"	d
MSTATUS_MPP_MASK	riscv.h	/^#define MSTATUS_MPP_MASK /;"	d
MSTATUS_MPP_S	riscv.h	/^#define MSTATUS_MPP_S /;"	d
MSTATUS_MPP_U	riscv.h	/^#define MSTATUS_MPP_U /;"	d
NBUF	param.h	/^#define NBUF /;"	d
NCPU	param.h	/^#define NCPU /;"	d
NDEV	param.h	/^#define NDEV /;"	d
NDIRECT	fs.h	/^#define NDIRECT /;"	d
NELEM	defs.h	/^#define NELEM(/;"	d
NFILE	param.h	/^#define NFILE /;"	d
NINDIRECT	fs.h	/^#define NINDIRECT /;"	d
NINODE	param.h	/^#define NINODE /;"	d
NOFILE	param.h	/^#define NOFILE /;"	d
NPROC	param.h	/^#define NPROC /;"	d
NUM	virtio.h	/^#define NUM /;"	d
O_CREATE	fcntl.h	/^#define O_CREATE /;"	d
O_RDONLY	fcntl.h	/^#define O_RDONLY /;"	d
O_RDWR	fcntl.h	/^#define O_RDWR /;"	d
O_TRUNC	fcntl.h	/^#define O_TRUNC /;"	d
O_WRONLY	fcntl.h	/^#define O_WRONLY /;"	d
PA2PTE	riscv.h	/^#define PA2PTE(/;"	d
PGROUNDDOWN	riscv.h	/^#define PGROUNDDOWN(/;"	d
PGROUNDUP	riscv.h	/^#define PGROUNDUP(/;"	d
PGSHIFT	riscv.h	/^#define PGSHIFT /;"	d
PGSIZE	riscv.h	/^#define PGSIZE /;"	d
PHYSTOP	memlayout.h	/^#define PHYSTOP /;"	d
PIPESIZE	pipe.c	/^#define PIPESIZE /;"	d	file:
PLIC	memlayout.h	/^#define PLIC /;"	d
PLIC_PENDING	memlayout.h	/^#define PLIC_PENDING /;"	d
PLIC_PRIORITY	memlayout.h	/^#define PLIC_PRIORITY /;"	d
PLIC_SCLAIM	memlayout.h	/^#define PLIC_SCLAIM(/;"	d
PLIC_SENABLE	memlayout.h	/^#define PLIC_SENABLE(/;"	d
PLIC_SPRIORITY	memlayout.h	/^#define PLIC_SPRIORITY(/;"	d
PTE2PA	riscv.h	/^#define PTE2PA(/;"	d
PTE_FLAGS	riscv.h	/^#define PTE_FLAGS(/;"	d
PTE_R	riscv.h	/^#define PTE_R /;"	d
PTE_U	riscv.h	/^#define PTE_U /;"	d
PTE_V	riscv.h	/^#define PTE_V /;"	d
PTE_W	riscv.h	/^#define PTE_W /;"	d
PTE_X	riscv.h	/^#define PTE_X /;"	d
PX	riscv.h	/^#define PX(/;"	d
PXMASK	riscv.h	/^#define PXMASK /;"	d
PXSHIFT	riscv.h	/^#define PXSHIFT(/;"	d
R	virtio_disk.c	/^#define R(/;"	d	file:
RHR	uart.c	/^#define RHR /;"	d	file:
ROOTDEV	param.h	/^#define ROOTDEV /;"	d
ROOTINO	fs.h	/^#define ROOTINO /;"	d
RUNNABLE	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ReadReg	uart.c	/^#define ReadReg(/;"	d	file:
Reg	uart.c	/^#define Reg(/;"	d	file:
SATP_SV39	riscv.h	/^#define SATP_SV39 /;"	d
SIE_SEIE	riscv.h	/^#define SIE_SEIE /;"	d
SIE_SSIE	riscv.h	/^#define SIE_SSIE /;"	d
SIE_STIE	riscv.h	/^#define SIE_STIE /;"	d
SLEEPING	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SSTATUS_SIE	riscv.h	/^#define SSTATUS_SIE /;"	d
SSTATUS_SPIE	riscv.h	/^#define SSTATUS_SPIE /;"	d
SSTATUS_SPP	riscv.h	/^#define SSTATUS_SPP /;"	d
SSTATUS_UIE	riscv.h	/^#define SSTATUS_UIE /;"	d
SSTATUS_UPIE	riscv.h	/^#define SSTATUS_UPIE /;"	d
SYS_chdir	syscall.h	/^#define SYS_chdir /;"	d
SYS_close	syscall.h	/^#define SYS_close /;"	d
SYS_dup	syscall.h	/^#define SYS_dup /;"	d
SYS_exec	syscall.h	/^#define SYS_exec /;"	d
SYS_exit	syscall.h	/^#define SYS_exit /;"	d
SYS_fork	syscall.h	/^#define SYS_fork /;"	d
SYS_fstat	syscall.h	/^#define SYS_fstat /;"	d
SYS_getpid	syscall.h	/^#define SYS_getpid /;"	d
SYS_kill	syscall.h	/^#define SYS_kill /;"	d
SYS_link	syscall.h	/^#define SYS_link /;"	d
SYS_mkdir	syscall.h	/^#define SYS_mkdir /;"	d
SYS_mknod	syscall.h	/^#define SYS_mknod /;"	d
SYS_open	syscall.h	/^#define SYS_open /;"	d
SYS_pipe	syscall.h	/^#define SYS_pipe /;"	d
SYS_read	syscall.h	/^#define SYS_read /;"	d
SYS_sbrk	syscall.h	/^#define SYS_sbrk /;"	d
SYS_sleep	syscall.h	/^#define SYS_sleep /;"	d
SYS_unlink	syscall.h	/^#define SYS_unlink /;"	d
SYS_uptime	syscall.h	/^#define SYS_uptime /;"	d
SYS_wait	syscall.h	/^#define SYS_wait /;"	d
SYS_write	syscall.h	/^#define SYS_write /;"	d
THR	uart.c	/^#define THR /;"	d	file:
TRAMPOLINE	memlayout.h	/^#define TRAMPOLINE /;"	d
TRAPFRAME	memlayout.h	/^#define TRAPFRAME /;"	d
T_DEVICE	stat.h	/^#define T_DEVICE /;"	d
T_DIR	stat.h	/^#define T_DIR /;"	d
T_FILE	stat.h	/^#define T_FILE /;"	d
UART0	memlayout.h	/^#define UART0 /;"	d
UART0_IRQ	memlayout.h	/^#define UART0_IRQ /;"	d
UART_TX_BUF_SIZE	uart.c	/^#define UART_TX_BUF_SIZE /;"	d	file:
UNUSED	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
USED	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
VIRTIO0	memlayout.h	/^#define VIRTIO0 /;"	d
VIRTIO0_IRQ	memlayout.h	/^#define VIRTIO0_IRQ /;"	d
VIRTIO_BLK_F_CONFIG_WCE	virtio.h	/^#define VIRTIO_BLK_F_CONFIG_WCE /;"	d
VIRTIO_BLK_F_MQ	virtio.h	/^#define VIRTIO_BLK_F_MQ /;"	d
VIRTIO_BLK_F_RO	virtio.h	/^#define VIRTIO_BLK_F_RO /;"	d
VIRTIO_BLK_F_SCSI	virtio.h	/^#define VIRTIO_BLK_F_SCSI /;"	d
VIRTIO_BLK_T_IN	virtio.h	/^#define VIRTIO_BLK_T_IN /;"	d
VIRTIO_BLK_T_OUT	virtio.h	/^#define VIRTIO_BLK_T_OUT /;"	d
VIRTIO_CONFIG_S_ACKNOWLEDGE	virtio.h	/^#define VIRTIO_CONFIG_S_ACKNOWLEDGE	/;"	d
VIRTIO_CONFIG_S_DRIVER	virtio.h	/^#define VIRTIO_CONFIG_S_DRIVER	/;"	d
VIRTIO_CONFIG_S_DRIVER_OK	virtio.h	/^#define VIRTIO_CONFIG_S_DRIVER_OK	/;"	d
VIRTIO_CONFIG_S_FEATURES_OK	virtio.h	/^#define VIRTIO_CONFIG_S_FEATURES_OK	/;"	d
VIRTIO_F_ANY_LAYOUT	virtio.h	/^#define VIRTIO_F_ANY_LAYOUT /;"	d
VIRTIO_MMIO_DEVICE_DESC_HIGH	virtio.h	/^#define VIRTIO_MMIO_DEVICE_DESC_HIGH	/;"	d
VIRTIO_MMIO_DEVICE_DESC_LOW	virtio.h	/^#define VIRTIO_MMIO_DEVICE_DESC_LOW	/;"	d
VIRTIO_MMIO_DEVICE_FEATURES	virtio.h	/^#define VIRTIO_MMIO_DEVICE_FEATURES	/;"	d
VIRTIO_MMIO_DEVICE_ID	virtio.h	/^#define VIRTIO_MMIO_DEVICE_ID	/;"	d
VIRTIO_MMIO_DRIVER_DESC_HIGH	virtio.h	/^#define VIRTIO_MMIO_DRIVER_DESC_HIGH	/;"	d
VIRTIO_MMIO_DRIVER_DESC_LOW	virtio.h	/^#define VIRTIO_MMIO_DRIVER_DESC_LOW	/;"	d
VIRTIO_MMIO_DRIVER_FEATURES	virtio.h	/^#define VIRTIO_MMIO_DRIVER_FEATURES	/;"	d
VIRTIO_MMIO_INTERRUPT_ACK	virtio.h	/^#define VIRTIO_MMIO_INTERRUPT_ACK	/;"	d
VIRTIO_MMIO_INTERRUPT_STATUS	virtio.h	/^#define VIRTIO_MMIO_INTERRUPT_STATUS	/;"	d
VIRTIO_MMIO_MAGIC_VALUE	virtio.h	/^#define VIRTIO_MMIO_MAGIC_VALUE	/;"	d
VIRTIO_MMIO_QUEUE_DESC_HIGH	virtio.h	/^#define VIRTIO_MMIO_QUEUE_DESC_HIGH	/;"	d
VIRTIO_MMIO_QUEUE_DESC_LOW	virtio.h	/^#define VIRTIO_MMIO_QUEUE_DESC_LOW	/;"	d
VIRTIO_MMIO_QUEUE_NOTIFY	virtio.h	/^#define VIRTIO_MMIO_QUEUE_NOTIFY	/;"	d
VIRTIO_MMIO_QUEUE_NUM	virtio.h	/^#define VIRTIO_MMIO_QUEUE_NUM	/;"	d
VIRTIO_MMIO_QUEUE_NUM_MAX	virtio.h	/^#define VIRTIO_MMIO_QUEUE_NUM_MAX	/;"	d
VIRTIO_MMIO_QUEUE_READY	virtio.h	/^#define VIRTIO_MMIO_QUEUE_READY	/;"	d
VIRTIO_MMIO_QUEUE_SEL	virtio.h	/^#define VIRTIO_MMIO_QUEUE_SEL	/;"	d
VIRTIO_MMIO_STATUS	virtio.h	/^#define VIRTIO_MMIO_STATUS	/;"	d
VIRTIO_MMIO_VENDOR_ID	virtio.h	/^#define VIRTIO_MMIO_VENDOR_ID	/;"	d
VIRTIO_MMIO_VERSION	virtio.h	/^#define VIRTIO_MMIO_VERSION	/;"	d
VIRTIO_RING_F_EVENT_IDX	virtio.h	/^#define VIRTIO_RING_F_EVENT_IDX /;"	d
VIRTIO_RING_F_INDIRECT_DESC	virtio.h	/^#define VIRTIO_RING_F_INDIRECT_DESC /;"	d
VRING_DESC_F_NEXT	virtio.h	/^#define VRING_DESC_F_NEXT /;"	d
VRING_DESC_F_WRITE	virtio.h	/^#define VRING_DESC_F_WRITE /;"	d
WriteReg	uart.c	/^#define WriteReg(/;"	d	file:
ZOMBIE	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
__anon081078bd0108	virtio_disk.c	/^  struct {$/;"	s	struct:disk	file:
__anon0f27d3d00108	bio.c	/^struct {$/;"	s	file:
__anon1ce500090108	printf.c	/^static struct {$/;"	s	file:
__anon69d64d0c0108	kalloc.c	/^struct {$/;"	s	file:
__anon7c96edaf0108	fs.c	/^struct {$/;"	s	file:
__anon96a473a90108	console.c	/^struct {$/;"	s	file:
__anonfd762eb60108	file.c	/^struct {$/;"	s	file:
__anonfd762ebb0103	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	g	struct:file
_entry	entry.S	/^_entry:$/;"	l
_trampoline	kernel.ld	/^    _trampoline = .;$/;"	s	section:.text
a	kernel.asm	/^    a = (uint*)bp->data;$/;"	d
a	kernel.asm	/^  a = va;$/;"	d
a0	proc.h	/^  \/* 112 *\/ uint64 a0;$/;"	m	struct:trapframe	typeref:typename:uint64
a1	proc.h	/^  \/* 120 *\/ uint64 a1;$/;"	m	struct:trapframe	typeref:typename:uint64
a2	proc.h	/^  \/* 128 *\/ uint64 a2;$/;"	m	struct:trapframe	typeref:typename:uint64
a3	proc.h	/^  \/* 136 *\/ uint64 a3;$/;"	m	struct:trapframe	typeref:typename:uint64
a4	proc.h	/^  \/* 144 *\/ uint64 a4;$/;"	m	struct:trapframe	typeref:typename:uint64
a5	proc.h	/^  \/* 152 *\/ uint64 a5;$/;"	m	struct:trapframe	typeref:typename:uint64
a6	proc.h	/^  \/* 160 *\/ uint64 a6;$/;"	m	struct:trapframe	typeref:typename:uint64
a7	proc.h	/^  \/* 168 *\/ uint64 a7;$/;"	m	struct:trapframe	typeref:typename:uint64
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f	typeref:typename:void
acquiresleep	sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f	typeref:typename:void
addr	kernel.asm	/^      addr = balloc(ip->dev);$/;"	d
addr	kernel.asm	/^  addr = myproc()->sz;$/;"	d
addr	virtio.h	/^  uint64 addr;$/;"	m	struct:virtq_desc	typeref:typename:uint64
addrs	file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode	typeref:typename:uint[]
addrs	fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode	typeref:typename:uint[]
align	elf.h	/^  uint64 align;$/;"	m	struct:proghdr	typeref:typename:uint64
alloc3_desc	virtio_disk.c	/^alloc3_desc(int *idx)$/;"	f	typeref:typename:int	file:
alloc_desc	virtio_disk.c	/^alloc_desc()$/;"	f	typeref:typename:int	file:
allocpid	proc.c	/^allocpid()$/;"	f	typeref:typename:int
allocproc	proc.c	/^allocproc(void)$/;"	f	typeref:struct:proc *	file:
argaddr	syscall.c	/^argaddr(int n, uint64 *ip)$/;"	f	typeref:typename:void
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	typeref:typename:int	file:
argint	syscall.c	/^argint(int n, int *ip)$/;"	f	typeref:typename:void
argraw	syscall.c	/^argraw(int n)$/;"	f	typeref:typename:uint64	file:
argstr	syscall.c	/^argstr(int n, char *buf, int max)$/;"	f	typeref:typename:int
avail	virtio_disk.c	/^  struct virtq_avail *avail;$/;"	m	struct:disk	typeref:struct:virtq_avail *	file:
b	kernel.asm	/^  b = bget(dev, blockno);$/;"	d
b	virtio_disk.c	/^    struct buf *b;$/;"	m	struct:disk::__anon081078bd0108	typeref:struct:buf *	file:
bad	kernel.asm	/^ bad:$/;"	l
balloc	fs.c	/^balloc(uint dev)$/;"	f	typeref:typename:uint	file:
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon0f27d3d00108
begin_op	log.c	/^begin_op(void)$/;"	f	typeref:typename:void
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	typeref:typename:void	file:
bget	bio.c	/^bget(uint dev, uint blockno)$/;"	f	typeref:struct:buf *	file:
bi	kernel.asm	/^  bi = b % BPB;$/;"	d
binit	bio.c	/^binit(void)$/;"	f	typeref:typename:void
block	log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	typeref:typename:int[]	file:
blockno	buf.h	/^  uint blockno;$/;"	m	struct:buf	typeref:typename:uint
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	typeref:typename:uint	file:
bmapstart	fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock	typeref:typename:uint
bp	kernel.asm	/^    bp = bread(dev, BBLOCK(b, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(dev, IBLOCK(inum, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, IBLOCK(ip->inum, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, addr);$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, ip->addrs[NDIRECT]);$/;"	d
bp	kernel.asm	/^  bp = bread(dev, 1);$/;"	d
bp	kernel.asm	/^  bp = bread(dev, BBLOCK(b, sb));$/;"	d
bp	kernel.asm	/^  bp = bread(dev, bno);$/;"	d
bp	kernel.asm	/^  bp = bread(ip->dev, IBLOCK(ip->inum, sb));$/;"	d
bpin	bio.c	/^bpin(struct buf *b) {$/;"	f	typeref:typename:void
bread	bio.c	/^bread(uint dev, uint blockno)$/;"	f	typeref:struct:buf *
brelse	bio.c	/^brelse(struct buf *b)$/;"	f	typeref:typename:void
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon0f27d3d00108	typeref:struct:buf[]	file:
buf	buf.h	/^struct buf {$/;"	s
buf	console.c	/^  char buf[INPUT_BUF_SIZE];$/;"	m	struct:__anon96a473a90108	typeref:typename:char[]	file:
bunpin	bio.c	/^bunpin(struct buf *b) {$/;"	f	typeref:typename:void
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f	typeref:typename:void
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	typeref:typename:void	file:
c	kernel.asm	/^      c = (c == '\\r') ? '\\n' : c;$/;"	d
c	kernel.asm	/^    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];$/;"	d
c	kernel.asm	/^    c = fmt[++i] & 0xff;$/;"	d
cbuf	kernel.asm	/^    cbuf = c;$/;"	d
ch	kernel.asm	/^    ch = pi->data[pi->nread++ % PIPESIZE];$/;"	d
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc	typeref:typename:void *
clockintr	trap.c	/^clockintr()$/;"	f	typeref:typename:void
commit	log.c	/^commit()$/;"	f	typeref:typename:void	file:
committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	typeref:typename:int	file:
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon96a473a90108
consoleinit	console.c	/^consoleinit(void)$/;"	f	typeref:typename:void
consoleintr	console.c	/^consoleintr(int c)$/;"	f	typeref:typename:void
consoleread	console.c	/^consoleread(int user_dst, uint64 dst, int n)$/;"	f	typeref:typename:int
consolewrite	console.c	/^consolewrite(int user_src, uint64 src, int n)$/;"	f	typeref:typename:int
consputc	console.c	/^consputc(int c)$/;"	f	typeref:typename:void
context	proc.h	/^  struct context context;      \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:context
context	proc.h	/^  struct context context;     \/\/ swtch() here to enter scheduler().$/;"	m	struct:cpu	typeref:struct:context
context	proc.h	/^struct context {$/;"	s
copyin	vm.c	/^copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)$/;"	f	typeref:typename:int
copyinstr	vm.c	/^copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)$/;"	f	typeref:typename:int
copyout	vm.c	/^copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)$/;"	f	typeref:typename:int
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:cpu *
cpuid	proc.c	/^cpuid()$/;"	f	typeref:typename:int
cpus	proc.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu[]
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	typeref:struct:inode *	file:
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:inode *
d	kernel.asm	/^  d = dst;$/;"	d
data	buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf	typeref:typename:uchar[]
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	typeref:typename:char[]	file:
desc	virtio_disk.c	/^  struct virtq_desc *desc;$/;"	m	struct:disk	typeref:struct:virtq_desc *	file:
dev	buf.h	/^  uint dev;$/;"	m	struct:buf	typeref:typename:uint
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode	typeref:typename:uint
dev	log.c	/^  int dev;$/;"	m	struct:log	typeref:typename:int	file:
dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat	typeref:typename:int
devintr	trap.c	/^devintr()$/;"	f	typeref:typename:int
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw[]
devsw	file.h	/^struct devsw {$/;"	s
digits	printf.c	/^static char digits[] = "0123456789abcdef";$/;"	v	typeref:typename:char[]	file:
dinode	fs.h	/^struct dinode {$/;"	s
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + inum%IPB;$/;"	d
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dip	kernel.asm	/^  dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dirent	fs.h	/^struct dirent {$/;"	s
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f	typeref:typename:int
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f	typeref:struct:inode *
disk	buf.h	/^  int disk;    \/\/ does disk "own" buf?$/;"	m	struct:buf	typeref:typename:int
disk	virtio_disk.c	/^static struct disk {$/;"	s	file:
disk	virtio_disk.c	/^} disk;$/;"	v	typeref:struct:disk
do_commit	kernel.asm	/^    do_commit = 1;$/;"	d
dstva	kernel.asm	/^    dstva = va0 + PGSIZE;$/;"	d
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon96a473a90108	typeref:typename:uint	file:
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr	typeref:typename:ushort
either_copyin	proc.c	/^either_copyin(void *dst, int user_src, uint64 src, uint64 len)$/;"	f	typeref:typename:int
either_copyout	proc.c	/^either_copyout(int user_dst, uint64 dst, void *src, uint64 len)$/;"	f	typeref:typename:int
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr	typeref:typename:uchar[12]
elfhdr	elf.h	/^struct elfhdr {$/;"	s
empty	kernel.asm	/^  empty = 0;$/;"	d
end	kernel.ld	/^  PROVIDE(end = .);$/;"	s	assignment:provide
end_op	log.c	/^end_op(void)$/;"	f	typeref:typename:void
entry	elf.h	/^  uint64 entry;$/;"	m	struct:elfhdr	typeref:typename:uint64
epc	proc.h	/^  \/*  24 *\/ uint64 epc;           \/\/ saved user program counter$/;"	m	struct:trapframe	typeref:typename:uint64
err	kernel.asm	/^ err:$/;"	l
etext	kernel.ld	/^    PROVIDE(etext = .);$/;"	s	section:.text	assignment:provide
exec	exec.c	/^exec(char *path, char **argv)$/;"	f	typeref:typename:int
exit	proc.c	/^exit(int status)$/;"	f	typeref:typename:void
extern	kernel.asm	/^extern int devintr();$/;"	l
fd0	kernel.asm	/^  fd0 = -1;$/;"	d
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	typeref:typename:int	file:
fetchaddr	syscall.c	/^fetchaddr(uint64 addr, uint64 *ip)$/;"	f	typeref:typename:int
fetchstr	syscall.c	/^fetchstr(uint64 addr, char *buf, int max)$/;"	f	typeref:typename:int
ff	kernel.asm	/^  ff = *f;$/;"	d
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anonfd762eb60108	typeref:struct:file[]	file:
file	file.h	/^struct file {$/;"	s
filealloc	file.c	/^filealloc(void)$/;"	f	typeref:struct:file *
fileclose	file.c	/^fileclose(struct file *f)$/;"	f	typeref:typename:void
filedup	file.c	/^filedup(struct file *f)$/;"	f	typeref:struct:file *
fileinit	file.c	/^fileinit(void)$/;"	f	typeref:typename:void
fileread	file.c	/^fileread(struct file *f, uint64 addr, int n)$/;"	f	typeref:typename:int
filestat	file.c	/^filestat(struct file *f, uint64 addr)$/;"	f	typeref:typename:int
filesz	elf.h	/^  uint64 filesz;$/;"	m	struct:proghdr	typeref:typename:uint64
filewrite	file.c	/^filewrite(struct file *f, uint64 addr, int n)$/;"	f	typeref:typename:int
first	kernel.asm	/^    first = 0;$/;"	d
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr	typeref:typename:uint
flags	elf.h	/^  uint32 flags;$/;"	m	struct:proghdr	typeref:typename:uint32
flags	kernel.asm	/^    flags = PTE_FLAGS(*pte);$/;"	d
flags	virtio.h	/^  uint16 flags; \/\/ always zero$/;"	m	struct:virtq_avail	typeref:typename:uint16
flags	virtio.h	/^  uint16 flags; \/\/ always zero$/;"	m	struct:virtq_used	typeref:typename:uint16
flags	virtio.h	/^  uint16 flags;$/;"	m	struct:virtq_desc	typeref:typename:uint16
flags2perm	exec.c	/^int flags2perm(int flags)$/;"	f	typeref:typename:int
fork	proc.c	/^fork(void)$/;"	f	typeref:typename:int
forkret	proc.c	/^forkret(void)$/;"	f	typeref:typename:void
free	virtio_disk.c	/^  char free[NUM];  \/\/ is a descriptor free?$/;"	m	struct:disk	typeref:typename:char[]	file:
free_chain	virtio_disk.c	/^free_chain(int i)$/;"	f	typeref:typename:void	file:
free_desc	virtio_disk.c	/^free_desc(int i)$/;"	f	typeref:typename:void	file:
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon69d64d0c0108	typeref:struct:run *	file:
freeproc	proc.c	/^freeproc(struct proc *p)$/;"	f	typeref:typename:void	file:
freerange	kalloc.c	/^freerange(void *pa_start, void *pa_end)$/;"	f	typeref:typename:void
freewalk	vm.c	/^freewalk(pagetable_t pagetable)$/;"	f	typeref:typename:void
fsinit	fs.c	/^fsinit(int dev) {$/;"	f	typeref:typename:void
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anonfd762eb60108
gp	proc.h	/^  \/*  56 *\/ uint64 gp;$/;"	m	struct:trapframe	typeref:typename:uint64
growproc	proc.c	/^growproc(int n)$/;"	f	typeref:typename:int
havekids	kernel.asm	/^        havekids = 1;$/;"	d
havekids	kernel.asm	/^    havekids = 0;$/;"	d
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon0f27d3d00108	typeref:struct:buf	file:
holding	spinlock.c	/^holding(struct spinlock *lk)$/;"	f	typeref:typename:int
holdingsleep	sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f	typeref:typename:int
i	kernel.asm	/^  i = 0;$/;"	d
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f	typeref:struct:inode *
id	virtio.h	/^  uint32 id;   \/\/ index of start of completed descriptor chain$/;"	m	struct:virtq_used_elem	typeref:typename:uint32
idup	fs.c	/^idup(struct inode *ip)$/;"	f	typeref:struct:inode *
idx	virtio.h	/^  uint16 idx;   \/\/ device increments when it adds a ring[] entry$/;"	m	struct:virtq_used	typeref:typename:uint16
idx	virtio.h	/^  uint16 idx;   \/\/ driver will write ring[idx] next$/;"	m	struct:virtq_avail	typeref:typename:uint16
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	typeref:struct:inode *	file:
iinit	fs.c	/^iinit()$/;"	f	typeref:typename:void
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f	typeref:typename:void
info	virtio_disk.c	/^  } info[NUM];$/;"	m	struct:disk	typeref:struct:disk::__anon081078bd0108[]	file:
initcode	proc.c	/^uchar initcode[] = {$/;"	v	typeref:typename:uchar[]
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f	typeref:typename:void
initlog	log.c	/^initlog(int dev, struct superblock *sb)$/;"	f	typeref:typename:void
initproc	kernel.asm	/^  initproc = p;$/;"	d
initproc	proc.c	/^struct proc *initproc;$/;"	v	typeref:struct:proc *
initsleeplock	sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f	typeref:typename:void
ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat	typeref:typename:uint
inode	file.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon7c96edaf0108	typeref:struct:inode[]	file:
inodestart	fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock	typeref:typename:uint
install_trans	log.c	/^install_trans(int recovering)$/;"	f	typeref:typename:void	file:
int	kernel.asm	/^int flags2perm(int flags)$/;"	l
int	kernel.asm	/^int$/;"	l
intena	kernel.asm	/^  intena = mycpu()->intena;$/;"	d
intena	proc.h	/^  int intena;                 \/\/ Were interrupts enabled before push_off()?$/;"	m	struct:cpu	typeref:typename:int
intr_get	riscv.h	/^intr_get()$/;"	f	typeref:typename:int
intr_off	riscv.h	/^intr_off()$/;"	f	typeref:typename:void
intr_on	riscv.h	/^intr_on()$/;"	f	typeref:typename:void
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode	typeref:typename:uint
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent	typeref:typename:ushort
inum	kernel.asm	/^      inum = de.inum;$/;"	d
ip	file.h	/^  struct inode *ip;  \/\/ FD_INODE and FD_DEVICE$/;"	m	struct:file	typeref:struct:inode *
ip	kernel.asm	/^    ip = create(path, T_FILE, 0, 0);$/;"	d
ip	kernel.asm	/^    ip = idup(myproc()->cwd);$/;"	d
ip	kernel.asm	/^    ip = iget(ROOTDEV, ROOTINO);$/;"	d
ip	kernel.asm	/^    ip = next;$/;"	d
ip	kernel.asm	/^  ip = 0;$/;"	d
iput	fs.c	/^iput(struct inode *ip)$/;"	f	typeref:typename:void
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	typeref:typename:int	file:
itable	fs.c	/^} itable;$/;"	v	typeref:struct:__anon7c96edaf0108
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	typeref:typename:void
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f	typeref:typename:void
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f	typeref:typename:void
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f	typeref:typename:void
k	kernel.asm	/^  k = p->killed;$/;"	d
kalloc	kalloc.c	/^kalloc(void)$/;"	f	typeref:typename:void *
kernel_hartid	proc.h	/^  \/*  32 *\/ uint64 kernel_hartid; \/\/ saved kernel tp$/;"	m	struct:trapframe	typeref:typename:uint64
kernel_pagetable	kernel.asm	/^  kernel_pagetable = kvmmake();$/;"	d
kernel_pagetable	vm.c	/^pagetable_t kernel_pagetable;$/;"	v	typeref:typename:pagetable_t
kernel_satp	proc.h	/^  \/*   0 *\/ uint64 kernel_satp;   \/\/ kernel page table$/;"	m	struct:trapframe	typeref:typename:uint64
kernel_sp	proc.h	/^  \/*   8 *\/ uint64 kernel_sp;     \/\/ top of process's kernel stack$/;"	m	struct:trapframe	typeref:typename:uint64
kernel_trap	proc.h	/^  \/*  16 *\/ uint64 kernel_trap;   \/\/ usertrap()$/;"	m	struct:trapframe	typeref:typename:uint64
kerneltrap	trap.c	/^kerneltrap()$/;"	f	typeref:typename:void
kernelvec	kernelvec.S	/^kernelvec:$/;"	l
kfree	kalloc.c	/^kfree(void *pa)$/;"	f	typeref:typename:void
kill	proc.c	/^kill(int pid)$/;"	f	typeref:typename:int
killed	proc.c	/^killed(struct proc *p)$/;"	f	typeref:typename:int
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc	typeref:typename:int
kinit	kalloc.c	/^kinit()$/;"	f	typeref:typename:void
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon69d64d0c0108
kpgtbl	kernel.asm	/^  kpgtbl = (pagetable_t) kalloc();$/;"	d
kstack	proc.h	/^  uint64 kstack;               \/\/ Virtual address of kernel stack$/;"	m	struct:proc	typeref:typename:uint64
kvminit	vm.c	/^kvminit(void)$/;"	f	typeref:typename:void
kvminithart	vm.c	/^kvminithart()$/;"	f	typeref:typename:void
kvmmake	vm.c	/^kvmmake(void)$/;"	f	typeref:typename:pagetable_t
kvmmap	vm.c	/^kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)$/;"	f	typeref:typename:void
last	kernel.asm	/^      last = s+1;$/;"	d
last	kernel.asm	/^  last = va + size - PGSIZE;$/;"	d
len	kernel.asm	/^  len = path - s;$/;"	d
len	virtio.h	/^  uint32 len;$/;"	m	struct:virtq_desc	typeref:typename:uint32
len	virtio.h	/^  uint32 len;$/;"	m	struct:virtq_used_elem	typeref:typename:uint32
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:logheader	file:
lk	sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:spinlock
loadseg	exec.c	/^loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz)$/;"	f	typeref:typename:int	file:
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon0f27d3d00108	typeref:struct:spinlock	file:
lock	buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:sleeplock
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon96a473a90108	typeref:struct:spinlock	file:
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anonfd762eb60108	typeref:struct:spinlock	file:
lock	file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:sleeplock
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon7c96edaf0108	typeref:struct:spinlock	file:
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon69d64d0c0108	typeref:struct:spinlock	file:
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:spinlock	file:
lock	printf.c	/^  struct spinlock lock;$/;"	m	struct:__anon1ce500090108	typeref:struct:spinlock	file:
lock	proc.h	/^  struct spinlock lock;$/;"	m	struct:proc	typeref:struct:spinlock
locked	sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock	typeref:typename:uint
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock	typeref:typename:uint
locking	kernel.asm	/^  locking = pr.locking;$/;"	d
locking	printf.c	/^  int locking;$/;"	m	struct:__anon1ce500090108	typeref:typename:int	file:
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log_write	log.c	/^log_write(struct buf *b)$/;"	f	typeref:typename:void
logheader	log.c	/^struct logheader {$/;"	s	file:
logstart	fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock	typeref:typename:uint
m	kernel.asm	/^      m = 1 << (bi % 8);$/;"	d
m	kernel.asm	/^    m = min(n - tot, BSIZE - off%BSIZE);$/;"	d
m	kernel.asm	/^  m = 1 << (bi % 8);$/;"	d
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr	typeref:typename:ushort
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr	typeref:typename:uint
magic	fs.h	/^  uint magic;        \/\/ Must be FSMAGIC$/;"	m	struct:superblock	typeref:typename:uint
main	main.c	/^main()$/;"	f	typeref:typename:void
major	file.h	/^  short major;       \/\/ FD_DEVICE$/;"	m	struct:file	typeref:typename:short
major	file.h	/^  short major;$/;"	m	struct:inode	typeref:typename:short
major	file.h	/^#define major(/;"	d
major	fs.h	/^  short major;          \/\/ Major device number (T_DEVICE only)$/;"	m	struct:dinode	typeref:typename:short
mappages	vm.c	/^mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)$/;"	f	typeref:typename:int
mem	kernel.asm	/^    mem = kalloc();$/;"	d
mem	kernel.asm	/^  mem = kalloc();$/;"	d
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f	typeref:typename:int
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f	typeref:typename:void *
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f	typeref:typename:void *
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f	typeref:typename:void *
memsz	elf.h	/^  uint64 memsz;$/;"	m	struct:proghdr	typeref:typename:uint64
min	fs.c	/^#define min(/;"	d	file:
minor	file.h	/^  short minor;$/;"	m	struct:inode	typeref:typename:short
minor	file.h	/^#define minor(/;"	d
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEVICE only)$/;"	m	struct:dinode	typeref:typename:short
mkdev	file.h	/^#define	mkdev(/;"	d
mycpu	proc.c	/^mycpu(void)$/;"	f	typeref:struct:cpu *
myproc	proc.c	/^myproc(void)$/;"	f	typeref:struct:proc *
n	kernel.asm	/^      n = PGSIZE;$/;"	d
n	kernel.asm	/^      n = len;$/;"	d
n	kernel.asm	/^      n = max;$/;"	d
n	kernel.asm	/^      n = sz - i;$/;"	d
n	kernel.asm	/^    n = 0;$/;"	d
n	kernel.asm	/^    n = PGSIZE - (dstva - va0);$/;"	d
n	kernel.asm	/^    n = PGSIZE - (srcva - va0);$/;"	d
n	kernel.asm	/^    n = ip->size - off;$/;"	d
n	log.c	/^  int n;$/;"	m	struct:logheader	typeref:typename:int	file:
n1	kernel.asm	/^        n1 = max;$/;"	d
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent	typeref:typename:char[]
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc	typeref:typename:char[16]
name	sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock	typeref:typename:char *
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock	typeref:typename:char *
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f	typeref:typename:int
namei	fs.c	/^namei(char *path)$/;"	f	typeref:struct:inode *
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f	typeref:struct:inode *
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	typeref:struct:inode *	file:
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock	typeref:typename:uint
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf *
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run *	file:
next	virtio.h	/^  uint16 next;$/;"	m	struct:virtq_desc	typeref:typename:uint16
nextpid	kernel.asm	/^  nextpid = nextpid + 1;$/;"	d
nextpid	proc.c	/^int nextpid = 1;$/;"	v	typeref:typename:int
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock	typeref:typename:uint
nlink	file.h	/^  short nlink;$/;"	m	struct:inode	typeref:typename:short
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode	typeref:typename:short
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat	typeref:typename:short
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock	typeref:typename:uint
noff	proc.h	/^  int noff;                   \/\/ Depth of push_off() nesting.$/;"	m	struct:cpu	typeref:typename:int
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	typeref:typename:uint	file:
num	kernel.asm	/^  num = p->trapframe->a7;$/;"	d
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	typeref:typename:uint	file:
off	elf.h	/^  uint64 off;$/;"	m	struct:proghdr	typeref:typename:uint64
off	file.h	/^  uint off;          \/\/ FD_INODE$/;"	m	struct:file	typeref:typename:uint
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:file * []
oldpagetable	kernel.asm	/^  oldpagetable = p->pagetable;$/;"	d
oldsz	kernel.asm	/^  oldsz = PGROUNDUP(oldsz);$/;"	d
ops	virtio_disk.c	/^  struct virtio_blk_req ops[NUM];$/;"	m	struct:disk	typeref:struct:virtio_blk_req[]	file:
os	kernel.asm	/^  os = s;$/;"	d
outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	typeref:typename:int	file:
p	kernel.asm	/^  p = (char*)PGROUNDUP((uint64)pa_start);$/;"	d
p	kernel.asm	/^  p = allocproc();$/;"	d
p	kernel.asm	/^  p = myproc();$/;"	d
pa	kernel.asm	/^    pa = PTE2PA(*pte);$/;"	d
pa	kernel.asm	/^    pa = walkaddr(pagetable, va + i);$/;"	d
pa	kernel.asm	/^  pa = PTE2PA(*pte);$/;"	d
pa0	kernel.asm	/^    pa0 = PTE2PA(*pte);$/;"	d
pa0	kernel.asm	/^    pa0 = walkaddr(pagetable, va0);$/;"	d
paddr	elf.h	/^  uint64 paddr;$/;"	m	struct:proghdr	typeref:typename:uint64
pagetable	kernel.asm	/^      pagetable = (pagetable_t)PTE2PA(*pte);$/;"	d
pagetable	kernel.asm	/^  pagetable = (pagetable_t) kalloc();$/;"	d
pagetable	kernel.asm	/^  pagetable = uvmcreate();$/;"	d
pagetable	proc.h	/^  pagetable_t pagetable;       \/\/ User page table$/;"	m	struct:proc	typeref:typename:pagetable_t
pagetable_t	kernel.asm	/^pagetable_t$/;"	l
pagetable_t	riscv.h	/^typedef uint64 *pagetable_t; \/\/ 512 PTEs$/;"	t	typeref:typename:uint64 *
panic	printf.c	/^panic(char *s)$/;"	f	typeref:typename:void
panicked	kernel.asm	/^  panicked = 1; \/\/ freeze uart output from other CPUs$/;"	d
panicked	printf.c	/^volatile int panicked = 0;$/;"	v	typeref:typename:volatile int
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc *
pde_t	types.h	/^typedef uint64 pde_t;$/;"	t	typeref:typename:uint64
perm	kernel.asm	/^      perm = PTE_X;$/;"	d
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr	typeref:typename:ushort
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr	typeref:typename:ushort
phoff	elf.h	/^  uint64 phoff;$/;"	m	struct:elfhdr	typeref:typename:uint64
pi	kernel.asm	/^  pi = 0;$/;"	d
pid	kernel.asm	/^          pid = pp->pid;$/;"	d
pid	kernel.asm	/^  pid = nextpid;$/;"	d
pid	kernel.asm	/^  pid = np->pid;$/;"	d
pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc	typeref:typename:int
pid	sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock	typeref:typename:int
pid_lock	proc.c	/^struct spinlock pid_lock;$/;"	v	typeref:struct:spinlock
pipe	file.h	/^  struct pipe *pipe; \/\/ FD_PIPE$/;"	m	struct:file	typeref:struct:pipe *
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f	typeref:typename:int
pipeclose	pipe.c	/^pipeclose(struct pipe *pi, int writable)$/;"	f	typeref:typename:void
piperead	pipe.c	/^piperead(struct pipe *pi, uint64 addr, int n)$/;"	f	typeref:typename:int
pipewrite	pipe.c	/^pipewrite(struct pipe *pi, uint64 addr, int n)$/;"	f	typeref:typename:int
plic_claim	plic.c	/^plic_claim(void)$/;"	f	typeref:typename:int
plic_complete	plic.c	/^plic_complete(int irq)$/;"	f	typeref:typename:void
plicinit	plic.c	/^plicinit(void)$/;"	f	typeref:typename:void
plicinithart	plic.c	/^plicinithart(void)$/;"	f	typeref:typename:void
pop_off	spinlock.c	/^pop_off(void)$/;"	f	typeref:typename:void
pr	printf.c	/^} pr;$/;"	v	typeref:struct:__anon1ce500090108
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf *
printf	printf.c	/^printf(char *fmt, ...)$/;"	f	typeref:typename:void
printfinit	printf.c	/^printfinit(void)$/;"	f	typeref:typename:void
printint	printf.c	/^printint(int xx, int base, int sign)$/;"	f	typeref:typename:void	file:
printptr	printf.c	/^printptr(uint64 x)$/;"	f	typeref:typename:void	file:
proc	proc.c	/^struct proc proc[NPROC];$/;"	v	typeref:struct:proc[]
proc	proc.h	/^  struct proc *proc;          \/\/ The process running on this cpu, or null.$/;"	m	struct:cpu	typeref:struct:proc *
proc	proc.h	/^struct proc {$/;"	s
proc_freepagetable	proc.c	/^proc_freepagetable(pagetable_t pagetable, uint64 sz)$/;"	f	typeref:typename:void
proc_mapstacks	proc.c	/^proc_mapstacks(pagetable_t kpgtbl)$/;"	f	typeref:typename:void
proc_pagetable	proc.c	/^proc_pagetable(struct proc *p)$/;"	f	typeref:typename:pagetable_t
procdump	proc.c	/^procdump(void)$/;"	f	typeref:typename:void
procinit	proc.c	/^procinit(void)$/;"	f	typeref:typename:void
procstate	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
proghdr	elf.h	/^struct proghdr {$/;"	s
pte	kernel.asm	/^    pte = walk(pagetable, va0, 0);$/;"	d
pte	kernel.asm	/^  pte = walk(pagetable, va, 0);$/;"	d
pte_t	kernel.asm	/^pte_t *$/;"	l
pte_t	riscv.h	/^typedef uint64 pte_t;$/;"	t	typeref:typename:uint64
push_off	spinlock.c	/^push_off(void)$/;"	f	typeref:typename:void
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon96a473a90108	typeref:typename:uint	file:
r	kernel.asm	/^    r = devsw[f->major].read(1, addr, n);$/;"	d
r	kernel.asm	/^    r = piperead(f->pipe, addr, n);$/;"	d
r	kernel.asm	/^  r = (lk->locked && lk->cpu == mycpu());$/;"	d
r	kernel.asm	/^  r = (struct run*)pa;$/;"	d
r	kernel.asm	/^  r = kmem.freelist;$/;"	d
r	kernel.asm	/^  r = lk->locked && (lk->pid == myproc()->pid);$/;"	d
r_mcounteren	riscv.h	/^r_mcounteren()$/;"	f	typeref:typename:uint64
r_medeleg	riscv.h	/^r_medeleg()$/;"	f	typeref:typename:uint64
r_mhartid	riscv.h	/^r_mhartid()$/;"	f	typeref:typename:uint64
r_mideleg	riscv.h	/^r_mideleg()$/;"	f	typeref:typename:uint64
r_mie	riscv.h	/^r_mie()$/;"	f	typeref:typename:uint64
r_mstatus	riscv.h	/^r_mstatus()$/;"	f	typeref:typename:uint64
r_ra	riscv.h	/^r_ra()$/;"	f	typeref:typename:uint64
r_satp	riscv.h	/^r_satp()$/;"	f	typeref:typename:uint64
r_scause	riscv.h	/^r_scause()$/;"	f	typeref:typename:uint64
r_sepc	riscv.h	/^r_sepc()$/;"	f	typeref:typename:uint64
r_sie	riscv.h	/^r_sie()$/;"	f	typeref:typename:uint64
r_sip	riscv.h	/^r_sip()$/;"	f	typeref:typename:uint64
r_sp	riscv.h	/^r_sp()$/;"	f	typeref:typename:uint64
r_sstatus	riscv.h	/^r_sstatus()$/;"	f	typeref:typename:uint64
r_stval	riscv.h	/^r_stval()$/;"	f	typeref:typename:uint64
r_stvec	riscv.h	/^r_stvec()$/;"	f	typeref:typename:uint64
r_time	riscv.h	/^r_time()$/;"	f	typeref:typename:uint64
r_tp	riscv.h	/^r_tp()$/;"	f	typeref:typename:uint64
ra	proc.h	/^  \/*  40 *\/ uint64 ra;$/;"	m	struct:trapframe	typeref:typename:uint64
ra	proc.h	/^  uint64 ra;$/;"	m	struct:context	typeref:typename:uint64
ramdiskinit	ramdisk.c	/^ramdiskinit(void)$/;"	f	typeref:typename:void
ramdiskrw	ramdisk.c	/^ramdiskrw(struct buf *b)$/;"	f	typeref:typename:void
read	file.h	/^  int (*read)(int, uint64, int);$/;"	m	struct:devsw	typeref:typename:int (*)(int,uint64,int)
read_head	log.c	/^read_head(void)$/;"	f	typeref:typename:void	file:
readable	file.h	/^  char readable;$/;"	m	struct:file	typeref:typename:char
readi	fs.c	/^readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)$/;"	f	typeref:typename:int
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	typeref:typename:int	file:
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f	typeref:typename:void	file:
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	typeref:typename:void	file:
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode	typeref:typename:int
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file	typeref:typename:int
refcnt	buf.h	/^  uint refcnt;$/;"	m	struct:buf	typeref:typename:uint
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f	typeref:typename:void
releasesleep	sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f	typeref:typename:void
reparent	proc.c	/^reparent(struct proc *p)$/;"	f	typeref:typename:void
reserved	virtio.h	/^  uint32 reserved;$/;"	m	struct:virtio_blk_req	typeref:typename:uint32
ret	kernel.asm	/^    ret = (i == n ? n : -1);$/;"	d
ret	kernel.asm	/^    ret = devsw[f->major].write(1, addr, n);$/;"	d
ret	kernel.asm	/^    ret = pipewrite(f->pipe, addr, n);$/;"	d
ring	virtio.h	/^  struct virtq_used_elem ring[NUM];$/;"	m	struct:virtq_used	typeref:struct:virtq_used_elem[]
ring	virtio.h	/^  uint16 ring[NUM]; \/\/ descriptor numbers of chain heads$/;"	m	struct:virtq_avail	typeref:typename:uint16[]
run	kalloc.c	/^struct run {$/;"	s	file:
s	kernel.asm	/^        s = "(null)";$/;"	d
s	kernel.asm	/^  s = src;$/;"	d
s0	proc.h	/^  \/*  96 *\/ uint64 s0;$/;"	m	struct:trapframe	typeref:typename:uint64
s0	proc.h	/^  uint64 s0;$/;"	m	struct:context	typeref:typename:uint64
s1	kernel.asm	/^  s1 = v1;$/;"	d
s1	proc.h	/^  \/* 104 *\/ uint64 s1;$/;"	m	struct:trapframe	typeref:typename:uint64
s1	proc.h	/^  uint64 s1;$/;"	m	struct:context	typeref:typename:uint64
s10	proc.h	/^  \/* 240 *\/ uint64 s10;$/;"	m	struct:trapframe	typeref:typename:uint64
s10	proc.h	/^  uint64 s10;$/;"	m	struct:context	typeref:typename:uint64
s11	proc.h	/^  \/* 248 *\/ uint64 s11;$/;"	m	struct:trapframe	typeref:typename:uint64
s11	proc.h	/^  uint64 s11;$/;"	m	struct:context	typeref:typename:uint64
s2	kernel.asm	/^  s2 = v2;$/;"	d
s2	proc.h	/^  \/* 176 *\/ uint64 s2;$/;"	m	struct:trapframe	typeref:typename:uint64
s2	proc.h	/^  uint64 s2;$/;"	m	struct:context	typeref:typename:uint64
s3	proc.h	/^  \/* 184 *\/ uint64 s3;$/;"	m	struct:trapframe	typeref:typename:uint64
s3	proc.h	/^  uint64 s3;$/;"	m	struct:context	typeref:typename:uint64
s4	proc.h	/^  \/* 192 *\/ uint64 s4;$/;"	m	struct:trapframe	typeref:typename:uint64
s4	proc.h	/^  uint64 s4;$/;"	m	struct:context	typeref:typename:uint64
s5	proc.h	/^  \/* 200 *\/ uint64 s5;$/;"	m	struct:trapframe	typeref:typename:uint64
s5	proc.h	/^  uint64 s5;$/;"	m	struct:context	typeref:typename:uint64
s6	proc.h	/^  \/* 208 *\/ uint64 s6;$/;"	m	struct:trapframe	typeref:typename:uint64
s6	proc.h	/^  uint64 s6;$/;"	m	struct:context	typeref:typename:uint64
s7	proc.h	/^  \/* 216 *\/ uint64 s7;$/;"	m	struct:trapframe	typeref:typename:uint64
s7	proc.h	/^  uint64 s7;$/;"	m	struct:context	typeref:typename:uint64
s8	proc.h	/^  \/* 224 *\/ uint64 s8;$/;"	m	struct:trapframe	typeref:typename:uint64
s8	proc.h	/^  uint64 s8;$/;"	m	struct:context	typeref:typename:uint64
s9	proc.h	/^  \/* 232 *\/ uint64 s9;$/;"	m	struct:trapframe	typeref:typename:uint64
s9	proc.h	/^  uint64 s9;$/;"	m	struct:context	typeref:typename:uint64
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f	typeref:typename:char *
sb	fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sched	proc.c	/^sched(void)$/;"	f	typeref:typename:void
scheduler	proc.c	/^scheduler(void)$/;"	f	typeref:typename:void
sector	virtio.h	/^  uint64 sector;$/;"	m	struct:virtio_blk_req	typeref:typename:uint64
setkilled	proc.c	/^setkilled(struct proc *p)$/;"	f	typeref:typename:void
sfence_vma	riscv.h	/^sfence_vma()$/;"	f	typeref:typename:void
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr	typeref:typename:ushort
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr	typeref:typename:ushort
shoff	elf.h	/^  uint64 shoff;$/;"	m	struct:elfhdr	typeref:typename:uint64
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr	typeref:typename:ushort
size	file.h	/^  uint size;$/;"	m	struct:inode	typeref:typename:uint
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode	typeref:typename:uint
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock	typeref:typename:uint
size	log.c	/^  int size;$/;"	m	struct:log	typeref:typename:int	file:
size	stat.h	/^  uint64 size; \/\/ Size of file in bytes$/;"	m	struct:stat	typeref:typename:uint64
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	typeref:typename:char *	file:
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f	typeref:typename:void
sleeplock	sleeplock.h	/^struct sleeplock {$/;"	s
sp	kernel.asm	/^  sp = sz;$/;"	d
sp	proc.h	/^  \/*  48 *\/ uint64 sp;$/;"	m	struct:trapframe	typeref:typename:uint64
sp	proc.h	/^  uint64 sp;$/;"	m	struct:context	typeref:typename:uint64
spin	entry.S	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
srcva	kernel.asm	/^    srcva = va0 + PGSIZE;$/;"	d
stack0	start.c	/^__attribute__ ((aligned (16))) char stack0[4096 * NCPU];$/;"	v	typeref:typename:char[]
stackbase	kernel.asm	/^  stackbase = sp - PGSIZE;$/;"	d
start	log.c	/^  int start;$/;"	m	struct:log	typeref:typename:int	file:
start	start.c	/^start()$/;"	f	typeref:typename:void
started	kernel.asm	/^    started = 1;$/;"	d
started	main.c	/^volatile static int started = 0;$/;"	v	typeref:typename:volatile int	file:
stat	stat.h	/^struct stat {$/;"	s
state	kernel.asm	/^      state = "???";$/;"	d
state	kernel.asm	/^      state = states[p->state];$/;"	d
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:procstate
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f	typeref:typename:void
static	kernel.asm	/^static char digits[] = "0123456789abcdef";$/;"	l
static	kernel.asm	/^static inline void$/;"	l
static	kernel.asm	/^static int loadseg(pde_t *, uint64, struct inode *, uint, uint);$/;"	l
static	kernel.asm	/^static int$/;"	l
static	kernel.asm	/^static struct inode*$/;"	t
static	kernel.asm	/^static uint$/;"	l
static	kernel.asm	/^static uint64$/;"	l
static	kernel.asm	/^static void$/;"	l
status	kernel.asm	/^  status = *R(VIRTIO_MMIO_STATUS);$/;"	d
status	virtio_disk.c	/^    char status;$/;"	m	struct:disk::__anon081078bd0108	typeref:typename:char	file:
strlen	string.c	/^strlen(const char *s)$/;"	f	typeref:typename:int
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f	typeref:typename:int
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f	typeref:typename:char *
struct	kernel.asm	/^  struct proc *p = c->proc;$/;"	l
struct	kernel.asm	/^  struct proc *p = myproc();$/;"	l
struct	kernel.asm	/^  struct proc *p;$/;"	l
struct	kernel.asm	/^  struct proc *pr = myproc();$/;"	l
superblock	fs.h	/^struct superblock {$/;"	s
swtch	swtch.S	/^swtch:$/;"	l
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f	typeref:typename:uint64
sys_close	sysfile.c	/^sys_close(void)$/;"	f	typeref:typename:uint64
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f	typeref:typename:uint64
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f	typeref:typename:uint64
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f	typeref:typename:uint64
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f	typeref:typename:uint64
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f	typeref:typename:uint64
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f	typeref:typename:uint64
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f	typeref:typename:uint64
sys_link	sysfile.c	/^sys_link(void)$/;"	f	typeref:typename:uint64
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f	typeref:typename:uint64
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f	typeref:typename:uint64
sys_open	sysfile.c	/^sys_open(void)$/;"	f	typeref:typename:uint64
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f	typeref:typename:uint64
sys_read	sysfile.c	/^sys_read(void)$/;"	f	typeref:typename:uint64
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f	typeref:typename:uint64
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f	typeref:typename:uint64
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f	typeref:typename:uint64
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f	typeref:typename:uint64
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f	typeref:typename:uint64
sys_write	sysfile.c	/^sys_write(void)$/;"	f	typeref:typename:uint64
syscall	syscall.c	/^syscall(void)$/;"	f	typeref:typename:void
syscalls	syscall.c	/^static uint64 (*syscalls[])(void) = {$/;"	v	typeref:typename:uint64 (* [])(void)	file:
sz	kernel.asm	/^    sz = uvmdealloc(p->pagetable, sz, sz + n);$/;"	d
sz	kernel.asm	/^  sz = PGROUNDUP(sz);$/;"	d
sz	kernel.asm	/^  sz = p->sz;$/;"	d
sz	kernel.asm	/^  sz = sz1;$/;"	d
sz	proc.h	/^  uint64 sz;                   \/\/ Size of process memory (bytes)$/;"	m	struct:proc	typeref:typename:uint64
t0	proc.h	/^  \/*  72 *\/ uint64 t0;$/;"	m	struct:trapframe	typeref:typename:uint64
t1	proc.h	/^  \/*  80 *\/ uint64 t1;$/;"	m	struct:trapframe	typeref:typename:uint64
t2	proc.h	/^  \/*  88 *\/ uint64 t2;$/;"	m	struct:trapframe	typeref:typename:uint64
t3	proc.h	/^  \/* 256 *\/ uint64 t3;$/;"	m	struct:trapframe	typeref:typename:uint64
t4	proc.h	/^  \/* 264 *\/ uint64 t4;$/;"	m	struct:trapframe	typeref:typename:uint64
t5	proc.h	/^  \/* 272 *\/ uint64 t5;$/;"	m	struct:trapframe	typeref:typename:uint64
t6	proc.h	/^  \/* 280 *\/ uint64 t6;$/;"	m	struct:trapframe	typeref:typename:uint64
target	kernel.asm	/^  target = n;$/;"	d
ticks	trap.c	/^uint ticks;$/;"	v	typeref:typename:uint
ticks0	kernel.asm	/^  ticks0 = ticks;$/;"	d
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
timer_scratch	start.c	/^uint64 timer_scratch[NCPU][5];$/;"	v	typeref:typename:uint64[][5]
timerinit	start.c	/^timerinit()$/;"	f	typeref:typename:void
timervec	kernelvec.S	/^timervec:$/;"	l
tot	kernel.asm	/^      tot = -1;$/;"	d
tp	proc.h	/^  \/*  64 *\/ uint64 tp;$/;"	m	struct:trapframe	typeref:typename:uint64
trampoline	trampoline.S	/^trampoline:$/;"	l
trapframe	proc.h	/^  struct trapframe *trapframe; \/\/ data page for trampoline.S$/;"	m	struct:proc	typeref:struct:trapframe *
trapframe	proc.h	/^struct trapframe {$/;"	s
trapinit	trap.c	/^trapinit(void)$/;"	f	typeref:typename:void
trapinithart	trap.c	/^trapinithart(void)$/;"	f	typeref:typename:void
type	elf.h	/^  uint32 type;$/;"	m	struct:proghdr	typeref:typename:uint32
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr	typeref:typename:ushort
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;$/;"	m	struct:file	typeref:enum:file::__anonfd762ebb0103
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode	typeref:typename:short
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode	typeref:typename:short
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat	typeref:typename:short
type	virtio.h	/^  uint32 type; \/\/ VIRTIO_BLK_T_IN or ..._OUT$/;"	m	struct:virtio_blk_req	typeref:typename:uint32
uart_tx_buf	uart.c	/^char uart_tx_buf[UART_TX_BUF_SIZE];$/;"	v	typeref:typename:char[]
uart_tx_lock	uart.c	/^struct spinlock uart_tx_lock;$/;"	v	typeref:struct:spinlock
uart_tx_r	uart.c	/^uint64 uart_tx_r; \/\/ read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]$/;"	v	typeref:typename:uint64
uart_tx_w	uart.c	/^uint64 uart_tx_w; \/\/ write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]$/;"	v	typeref:typename:uint64
uartgetc	uart.c	/^uartgetc(void)$/;"	f	typeref:typename:int
uartinit	uart.c	/^uartinit(void)$/;"	f	typeref:typename:void
uartintr	uart.c	/^uartintr(void)$/;"	f	typeref:typename:void
uartputc	uart.c	/^uartputc(int c)$/;"	f	typeref:typename:void
uartputc_sync	uart.c	/^uartputc_sync(int c)$/;"	f	typeref:typename:void
uartstart	uart.c	/^uartstart()$/;"	f	typeref:typename:void
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t	typeref:typename:unsigned char
uint	types.h	/^typedef unsigned int   uint;$/;"	t	typeref:typename:unsigned int
uint16	types.h	/^typedef unsigned short uint16;$/;"	t	typeref:typename:unsigned short
uint32	types.h	/^typedef unsigned int  uint32;$/;"	t	typeref:typename:unsigned int
uint64	kernel.asm	/^uint64$/;"	l
uint64	types.h	/^typedef unsigned long uint64;$/;"	t	typeref:typename:unsigned long
uint8	types.h	/^typedef unsigned char uint8;$/;"	t	typeref:typename:unsigned char
unused	virtio.h	/^  uint16 unused;$/;"	m	struct:virtq_avail	typeref:typename:uint16
used	virtio_disk.c	/^  struct virtq_used *used;$/;"	m	struct:disk	typeref:struct:virtq_used *	file:
used_idx	virtio_disk.c	/^  uint16 used_idx; \/\/ we've looked this far in used[2..NUM].$/;"	m	struct:disk	typeref:typename:uint16	file:
userinit	proc.c	/^userinit(void)$/;"	f	typeref:typename:void
userret	trampoline.S	/^userret:$/;"	l
usertrap	trap.c	/^usertrap(void)$/;"	f	typeref:typename:void
usertrapret	trap.c	/^usertrapret(void)$/;"	f	typeref:typename:void
uservec	trampoline.S	/^uservec:    $/;"	l
ushort	types.h	/^typedef unsigned short ushort;$/;"	t	typeref:typename:unsigned short
uvmalloc	vm.c	/^uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)$/;"	f	typeref:typename:uint64
uvmclear	vm.c	/^uvmclear(pagetable_t pagetable, uint64 va)$/;"	f	typeref:typename:void
uvmcopy	vm.c	/^uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)$/;"	f	typeref:typename:int
uvmcreate	vm.c	/^uvmcreate()$/;"	f	typeref:typename:pagetable_t
uvmdealloc	vm.c	/^uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)$/;"	f	typeref:typename:uint64
uvmfirst	vm.c	/^uvmfirst(pagetable_t pagetable, uchar *src, uint sz)$/;"	f	typeref:typename:void
uvmfree	vm.c	/^uvmfree(pagetable_t pagetable, uint64 sz)$/;"	f	typeref:typename:void
uvmunmap	vm.c	/^uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)$/;"	f	typeref:typename:void
va0	kernel.asm	/^    va0 = PGROUNDDOWN(dstva);$/;"	d
va0	kernel.asm	/^    va0 = PGROUNDDOWN(srcva);$/;"	d
vaddr	elf.h	/^  uint64 vaddr;$/;"	m	struct:proghdr	typeref:typename:uint64
valid	buf.h	/^  int valid;   \/\/ has data been read from disk?$/;"	m	struct:buf	typeref:typename:int
valid	file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode	typeref:typename:int
vdisk_lock	virtio_disk.c	/^  struct spinlock vdisk_lock;$/;"	m	struct:disk	typeref:struct:spinlock	file:
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr	typeref:typename:uint
virtio_blk_req	virtio.h	/^struct virtio_blk_req {$/;"	s
virtio_disk_init	virtio_disk.c	/^virtio_disk_init(void)$/;"	f	typeref:typename:void
virtio_disk_intr	virtio_disk.c	/^virtio_disk_intr()$/;"	f	typeref:typename:void
virtio_disk_rw	virtio_disk.c	/^virtio_disk_rw(struct buf *b, int write)$/;"	f	typeref:typename:void
virtq_avail	virtio.h	/^struct virtq_avail {$/;"	s
virtq_desc	virtio.h	/^struct virtq_desc {$/;"	s
virtq_used	virtio.h	/^struct virtq_used {$/;"	s
virtq_used_elem	virtio.h	/^struct virtq_used_elem {$/;"	s
void	kernel.asm	/^void *$/;"	l
void	kernel.asm	/^void uartstart();$/;"	l
void	kernel.asm	/^void$/;"	l
volatile	kernel.asm	/^volatile static int started = 0;$/;"	l
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon96a473a90108	typeref:typename:uint	file:
w_mcounteren	riscv.h	/^w_mcounteren(uint64 x)$/;"	f	typeref:typename:void
w_medeleg	riscv.h	/^w_medeleg(uint64 x)$/;"	f	typeref:typename:void
w_mepc	riscv.h	/^w_mepc(uint64 x)$/;"	f	typeref:typename:void
w_mideleg	riscv.h	/^w_mideleg(uint64 x)$/;"	f	typeref:typename:void
w_mie	riscv.h	/^w_mie(uint64 x)$/;"	f	typeref:typename:void
w_mscratch	riscv.h	/^w_mscratch(uint64 x)$/;"	f	typeref:typename:void
w_mstatus	riscv.h	/^w_mstatus(uint64 x)$/;"	f	typeref:typename:void
w_mtvec	riscv.h	/^w_mtvec(uint64 x)$/;"	f	typeref:typename:void
w_pmpaddr0	riscv.h	/^w_pmpaddr0(uint64 x)$/;"	f	typeref:typename:void
w_pmpcfg0	riscv.h	/^w_pmpcfg0(uint64 x)$/;"	f	typeref:typename:void
w_satp	riscv.h	/^w_satp(uint64 x)$/;"	f	typeref:typename:void
w_sepc	riscv.h	/^w_sepc(uint64 x)$/;"	f	typeref:typename:void
w_sie	riscv.h	/^w_sie(uint64 x)$/;"	f	typeref:typename:void
w_sip	riscv.h	/^w_sip(uint64 x)$/;"	f	typeref:typename:void
w_sstatus	riscv.h	/^w_sstatus(uint64 x)$/;"	f	typeref:typename:void
w_stvec	riscv.h	/^w_stvec(uint64 x)$/;"	f	typeref:typename:void
w_tp	riscv.h	/^w_tp(uint64 x)$/;"	f	typeref:typename:void
wait	proc.c	/^wait(uint64 addr)$/;"	f	typeref:typename:int
wait_lock	proc.c	/^struct spinlock wait_lock;$/;"	v	typeref:struct:spinlock
wakeup	proc.c	/^wakeup(void *chan)$/;"	f	typeref:typename:void
walk	vm.c	/^walk(pagetable_t pagetable, uint64 va, int alloc)$/;"	f	typeref:typename:pte_t *
walkaddr	vm.c	/^walkaddr(pagetable_t pagetable, uint64 va)$/;"	f	typeref:typename:uint64
writable	file.h	/^  char writable;$/;"	m	struct:file	typeref:typename:char
write	file.h	/^  int (*write)(int, uint64, int);$/;"	m	struct:devsw	typeref:typename:int (*)(int,uint64,int)
write_head	log.c	/^write_head(void)$/;"	f	typeref:typename:void	file:
write_log	log.c	/^write_log(void)$/;"	f	typeref:typename:void	file:
writei	fs.c	/^writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)$/;"	f	typeref:typename:int
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	typeref:typename:int	file:
x	kernel.asm	/^    x = -xx;$/;"	d
x	kernel.asm	/^    x = xx;$/;"	d
xstate	proc.h	/^  int xstate;                  \/\/ Exit status to be returned to parent's wait$/;"	m	struct:proc	typeref:typename:int
xticks	kernel.asm	/^  xticks = ticks;$/;"	d
yield	proc.c	/^yield(void)$/;"	f	typeref:typename:void
